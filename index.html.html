<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Match & Mix</title>
<style>
  :root{
    --bg:#ffe6f4; --card:#ffd4eb; --accent:#ff82c6; --muted:#94a3b8; --tile:#ffc4e3;
  }
  html,body{height:100%; margin:0; font-family:Inter,Segoe UI,Roboto,system-ui; background:linear-gradient(180deg,#ffe6f4,#ffffff); color:#000}
  .wrap{max-width:1100px;margin:24px auto;padding:20px;}
  h1{margin:0 0 8px;font-size:22px;color:#000}
  .top{display:flex;gap:16px;align-items:center;flex-wrap:wrap}
  .controls{display:flex;gap:8px;align-items:center}
  button{background:var(--accent);border:none;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}
  button.secondary{background:#253341;color:#cfeefc}
  .board-wrap{display:flex;gap:20px;margin-top:18px}
  .board{width:560px;height:560px;background:linear-gradient(180deg,#ffd4eb,#ffe6f4);padding:18px;border-radius:12px;display:grid;grid-template-columns:repeat(3,1fr);grid-template-rows:repeat(3,1fr);gap:12px;box-shadow:0 6px 30px rgba(0,0,0,0.06)}
  .slot{background:rgba(0,0,0,0.03);border-radius:10px;position:relative;display:flex;align-items:center;justify-content:center}
  .slot.empty{background:transparent;border:2px dashed rgba(0,0,0,0.06)}
  .tile{width:100%;height:100%;background:var(--tile);border-radius:10px;padding:8px;box-sizing:border-box;display:flex;flex-direction:column;gap:6px;cursor:pointer; user-select:none}
  .chips{display:grid;grid-template-columns:repeat(2,1fr);gap:6px;flex:1}
  .chip{background:rgba(255,255,255,0.06);height:70px;border-radius:6px;display:flex;align-items:center;justify-content:center;font-weight:800;cursor:pointer;transition:transform .12s;font-size:20px;color:#000}
  .chip.face{background:linear-gradient(180deg,#fff,#ffd5ee);color:#000; transform:translateY(-2px)}
  .chip.cover{background:linear-gradient(180deg,#ffc4e3,#ffb0d9);color:transparent}
  .info{flex:1; min-width:300px}
  .status{background:var(--card);padding:12px;border-radius:10px;box-shadow:inset 0 1px 0 rgba(0,0,0,0.02);color:#000}
  .row{display:flex;justify-content:space-between;gap:12px}
  .player{padding:8px;border-radius:8px;background:linear-gradient(180deg,#ff9ccf,#ff6fb5);display:flex;gap:8px;align-items:center;color:#fff}
  .player.active{outline:2px solid rgba(255,255,255,0.12);box-shadow:0 6px 18px rgba(0,0,0,0.06)}
  .big{font-size:20px;font-weight:1000;color:#fff}
  .small{font-size:13px;color:#000}
  .log{margin-top:12px;color:#000;font-size:13px;max-height:180px;overflow:auto;padding:8px;background:rgba(255,255,255,0.6);border-radius:8px}
@media (max-width: 600px){
  .board-wrap{flex-direction:column;align-items:center}
  .board{width:300px;height:300px;padding:10px;gap:6px}
  .chip{height:40px;font-size:16px}
}
@keyframes swipeAnim{0%{transform:translateX(0) scale(1);}50%{transform:translateX(8px) scale(1.03);}100%{transform:translateX(0) scale(1);} }
.tile.swipe{animation:swipeAnim .25s ease-out;}
</style>
</head>
<body>
<div class="wrap">
  <div class="top">
    <div>
      <h1>Match & Mix</h1>
    </div>
    <div class="controls">
      <button id="startBtn">Mulai Permainan</button>
      <button class="secondary" id="resetBtn">Reset</button>
    </div>
  </div>

  <div class="board-wrap">
    <div class="board" id="board"></div>

    <div class="info">
      <div class="status">
        <div class="row" style="margin-bottom:8px">
          <div class="player" id="p1"><div><div class="small">Player 1</div><div class="big" id="score1">0</div></div></div>
          <div class="player" id="p2"><div><div class="small">Player 2</div><div class="big" id="score2">0</div></div></div>
          <div class="small">Giliran: <strong id="turnLabel">-</strong></div>
          <div class="small">Waktu: <strong id="timer">—</strong></div>
        </div>
        <div class="log" id="log"></div>
      </div>
    </div>
  </div>
</div>

<script>
// Match & Mix (2-chip) — Updated behavior implemented.
// Rules implemented:
// - Start button immediately starts a 10s timer for the active player.
// - On correct match: chips remain open (matched), player may continue until time expires.
// - On mismatch: wrong chips are immediately closed, timer stops, player MUST slide one tile; after sliding the turn switches and the timer resets to 10s for the next player.
// - If timer reaches 0: wrong/unfinished selections are closed, player MUST slide one tile; after sliding the turn switches and the timer resets to 10s for the next player.

let slots = [];
let tiles = [];
let revealed = true; // initial reveal for memorization
let currentPlayer = 1;
let scores = [0,0];
let canFlip = false;
let flipBuffer = [];
let flipTimer = null;
let flipTimeLeft = 0;
let mustSlide = false;
let lastMovedTileId = null;
let gameOver = false;

const boardEl = document.getElementById('board');
const logEl = document.getElementById('log');
const timerEl = document.getElementById('timer');
const turnLabel = document.getElementById('turnLabel');
const score1El = document.getElementById('score1');
const score2El = document.getElementById('score2');
const p1El = document.getElementById('p1');
const p2El = document.getElementById('p2');

function log(m){ logEl.innerHTML = `<div>${m}</div>`; }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }

function initGame(){
  const pool = [];
  for(let i=1;i<=8;i++){ pool.push(i); pool.push(i); }
  shuffle(pool);

  tiles = [];
  for(let t=0;t<8;t++){
    const aIdx = Math.floor(Math.random()*pool.length);
    const aVal = pool.splice(aIdx,1)[0];
    let bIdx = pool.findIndex(x=>x!==aVal);
    if(bIdx===-1){ bIdx = Math.floor(Math.random()*pool.length); }
    const bVal = pool.splice(bIdx,1)[0];
    tiles.push({id:t, chips:[{value:aVal,matched:false,face:false},{value:bVal,matched:false,face:false}]});
  }

  const order = [...Array(9).keys()];
  shuffle(order);
  slots = Array(9).fill(null);
  for(let i=0;i<8;i++){ slots[order[i]] = tiles[i]; }

  revealed = true;
  currentPlayer = 1;
  scores = [0,0];
  mustSlide = false;
  gameOver = false;
  lastMovedTileId = null;

  renderBoard();
  updateUI();
  log("Papan siap.");
}

function renderBoard(){
  boardEl.innerHTML = "";
  for(let i=0;i<9;i++){
    const slot = document.createElement('div');
    slot.className = "slot" + (slots[i]===null ? " empty":"");
    if(slots[i]){
      const tile = slots[i];
      const tileEl = document.createElement('div');
      tileEl.className = "tile";
      tileEl.dataset.slot = i;
      const chipsEl = document.createElement('div');
      chipsEl.className="chips";
      tile.chips.forEach((chip,ci)=>{
        const c = document.createElement('div');
        c.className = "chip";
        if(revealed || chip.face || chip.matched){
          c.classList.add("face");
          c.textContent = chip.value;
        } else {
          c.classList.add("cover");
          c.textContent = "";
        }
        c.dataset.slot = i;
        c.dataset.chip = ci;
        // pass slot and chip index to onFlip to avoid issues with event.currentTarget later
        c.addEventListener("click", e=>{ e.stopPropagation(); onFlipSlot(i,ci); });
        chipsEl.appendChild(c);
      });
      tileEl.appendChild(chipsEl);
      tileEl.addEventListener("click",()=>trySlide(i));
      slot.appendChild(tileEl);
    }
    boardEl.appendChild(slot);
  }
}

function onFlipSlot(slot, ci){
  if(!canFlip || revealed || gameOver) return;
  const tile = slots[slot];
  if(!tile) return;
  const chip = tile.chips[ci];
  if(chip.matched || chip.face) return;

  // ignore if time expired
  if(flipTimeLeft<=0) return;

  chip.face = true;
  flipBuffer.push({slot,ci,value:chip.value});
  renderBoard();

  if(flipBuffer.length===1){
    if(!flipTimer) startTimer();
  } else if(flipBuffer.length===2){
    const [a,b] = flipBuffer;
    if(a.value===b.value){
      // match: mark matched, give point, allow continue until time ends
      slots[a.slot].chips[a.ci].matched = true;
      slots[b.slot].chips[b.ci].matched = true;
      scores[currentPlayer-1]++;
      updateUI();
      log(`Cocok! Player ${currentPlayer} dapat 1 poin!`);

      flipBuffer = [];
      renderBoard();
      canFlip = true;
    } else {
      // mismatch: show both chips first, then close after short delay
      stopTimer();
      canFlip = false;

      setTimeout(()=>{
        if(slots[a.slot]) slots[a.slot].chips[a.ci].face = false;
        if(slots[b.slot]) slots[b.slot].chips[b.ci].face = false;
        flipBuffer = [];
        renderBoard();
        mustSlide = true;
        log('Salah — geser satu ubin untuk melanjutkan.');
      }, 700);
    }
  }
}

function startTimer(){
  if(flipTimer) clearInterval(flipTimer);
  flipTimeLeft = 10;
  timerEl.textContent = flipTimeLeft + 's';
  flipTimer = setInterval(()=>{
    flipTimeLeft--;
    timerEl.textContent = flipTimeLeft + 's';
    if(flipTimeLeft<=0){
      clearInterval(flipTimer);
      flipTimer = null;
      // close any single open chip
      if(flipBuffer.length===1){
        const a = flipBuffer[0];
        if(slots[a.slot]) slots[a.slot].chips[a.ci].face = false;
      }
      flipBuffer = [];
      renderBoard();
      canFlip = false;
      mustSlide = true; // require slide when time ends
      log('Waktu habis — geser satu ubin.');
    }
  },1000);
}

function stopTimer(){
  if(flipTimer){ clearInterval(flipTimer); flipTimer = null; }
  timerEl.textContent = '—';
}

function trySlide(slotIdx){
  if(!mustSlide) return;
  const empty = slots.findIndex(s=>s===null);
  if(!isAdj(slotIdx,empty)) return log('Ubin harus bersebelahan dengan slot kosong.');

  const tile = slots[slotIdx];
  if(!tile) return;
  if(tile.id === lastMovedTileId) return log('Tidak boleh revert posisi ubin barusan.');

  const slotEl = boardEl.children[slotIdx];
  const tileEl = slotEl ? slotEl.querySelector('.tile') : null;
  if(tileEl) tileEl.classList.add('swipe');

  setTimeout(()=>{
    slots[empty] = tile;
    slots[slotIdx] = null;
    lastMovedTileId = tile.id;

    // after slide: reset state
    mustSlide = false;
    flipBuffer = [];
    stopTimer();

    // after slide, switch turn and start timer for next player
    currentPlayer = currentPlayer===1 ? 2 : 1;
    startTimer();
    canFlip = true;

    renderBoard();
    updateUI();
    log(`Ubin digeser. Giliran Player ${currentPlayer}.`);
  },250);
}

function isAdj(a,b){
  if(a<0||b<0) return false;
  const ax=a%3, ay=Math.floor(a/3);
  const bx=b%3, by=Math.floor(b/3);
  return Math.abs(ax-bx)+Math.abs(ay-by)===1;
}

function updateUI(){
  score1El.textContent = scores[0];
  score2El.textContent = scores[1];
  p1El.classList.toggle('active', currentPlayer===1);
  p2El.classList.toggle('active', currentPlayer===2);
  turnLabel.textContent = 'Player ' + currentPlayer;
}

function endGame(){
  gameOver = true;
  stopTimer();
  log(`GAME OVER — Player ${currentPlayer} menang!`);
  alert(`Player ${currentPlayer} menang!`);
}

// start button behavior: start timer immediately and enable flipping
document.getElementById('startBtn').onclick = () => {
  revealed = false;
  canFlip = true;
  renderBoard();

  stopTimer();
  startTimer();

  log('Permainan dimulai!');
  document.getElementById('startBtn').disabled = true;
};

document.getElementById('resetBtn').onclick = ()=>{
  initGame();
  stopTimer();
  document.getElementById('startBtn').disabled = false;
};

initGame();
</script>
</body>
</html>
